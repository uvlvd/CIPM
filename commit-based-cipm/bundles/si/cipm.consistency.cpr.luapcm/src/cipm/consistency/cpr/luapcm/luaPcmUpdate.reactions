import cipm.consistency.base.models.instrumentation.InstrumentationModel.InstrumentationModelPackage
import cipm.consistency.commitintegration.lang.lua.appspace.AppSpaceSemantics
import cipm.consistency.cpr.luapcm.Config
import cipm.consistency.cpr.luapcm.seffreconstruction.ActionReconstruction
import cipm.consistency.cpr.luapcm.seffreconstruction.ActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.BranchActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.ComponentSetInfoRegistry
import cipm.consistency.cpr.luapcm.seffreconstruction.CorrespondenceUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.SeffHelper
import cipm.consistency.cpr.luapcm.seffreconstruction.LuaFunctionDeclaration
import cipm.consistency.tools.evaluation.data.EvaluationDataContainer
import org.eclipse.xtext.EcoreUtil2
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.seff.BranchAction
import org.palladiosimulator.pcm.seff.ExternalCallAction
import org.palladiosimulator.pcm.seff.InternalAction
import org.palladiosimulator.pcm.seff.LoopAction
import org.palladiosimulator.pcm.seff.ProbabilisticBranchTransition
import org.palladiosimulator.pcm.seff.SeffFactory
import org.xtext.lua.lua.LuaUtil
import org.xtext.lua.lua.Block
import org.xtext.lua.lua.LastStatement_Return_WithValue
import org.xtext.lua.lua.LuaPackage
import org.xtext.lua.lua.Stat
//import org.xtext.lua.lua.Statement_Function_Declaration
import tools.vitruv.change.atomic.feature.FeatureEChange

import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm
import "http://www.dmodel.com/InstrumentationMetamodel" as im

reactions: luaPcmUpdate
in reaction to changes in lua
execute actions in pcm and im

/**
 * 
 * TODO TODO TODO
 * 
 * This is a nasty hack!
 * 
 * I'm having issues deactivating the action instrumentation points of the IM from outside the VSUM,
 * as the view that has the IM only returns an invalid IM without any point, which makes modifying them 
 * impossible.
 * 
 * So as a hack im doing it here
 */
reaction DeactivateAllIPs {
	after anychange
	call {
		if (change instanceof FeatureEChange) {
			var info = ComponentSetInfoRegistry.getInfosForComponentSet(change.affectedEObject)
			if (info !== null && !info.emulatedInstrumentationRan) {
				logger.warn("Deactivating all AIPs to emulate a complete instrumentation")
				deactiveAllAIPs()
				info.emulatedInstrumentationRan = true
			}
		}
	}
}

routine deactiveAllAIPs() {
	match {
		val im = retrieve im::InstrumentationModel corresponding to InstrumentationModelPackage.Literals.
			INSTRUMENTATION_MODEL
	}
	update {
		for (sip : im.points) {
			for (aip : sip.actionInstrumentationPoints) {
				aip.active = false
			}
		}
	}
}

reaction AddedBlock {
	after element lua::Block created
	call {
		createRDBehaviourForBlock(affectedEObject)
		updateStepsBehaviour(affectedEObject, affectedEObject.returnValue, null)
	}
}

reaction RemovedBlock {
	after element lua::Block deleted
	call {
		removeRDBehaviourForBlock(affectedEObject)
	}
}


// TODO this was added last minute and could probably use a look over
reaction ChangedBlockReturn {
	after element replaced at lua::Block[returnValue]
	call {
		val parentDeclaration = EcoreUtil2.getContainerOfType(affectedEObject, Statement_Function_Declaration)
		if (parentDeclaration !== null) {
			updateOperationSignature(parentDeclaration, newValue)
			updateStepsBehaviour(affectedEObject, newValue, oldValue)
		}
	}
}

reaction RemovedBlockReturn {
	after element removed from lua::Block[returnValue]
	call {
		removeActionsForStatement(oldValue, affectedEObject)
	}
}

routine updateStepsBehaviour(lua::Block block, lua::LastStatement lastStatement, lua::LastStatement prev) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (prev === null && lastStatement !== null) {
			createActionsForStatement(lastStatement, block)
		} else if (prev !== null && lastStatement === null) {
			removeActionsForStatement(prev, block)
		}
	}
}

// TODO move this to the other routines
routine updateOperationSignature(lua::Statement_Function_Declaration declaration, lua::LastStatement returnValue) {
	match {
		val signature = retrieve optional pcm::OperationSignature corresponding to declaration
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	update {
		if (signature.empty) {
			return
		}
		if (returnValue instanceof LastStatement_Return_WithValue) {
			if (returnValue.returnValues.size > 0) {
				signature.get.returnType__OperationSignature = luaAnyType
				return
			}
		}
		signature.get.returnType__OperationSignature = null
	}
}

reaction AddedLuaComponent {
	after element lua::Component inserted in lua::ComponentSet[components]
	call {
		if (newValue.name == "/stdlibAndCrowns.lua") {
			return
		}
		createBasicComponentForLuaComponent(newValue)
		createOperationInterfaceForLuaComponent(newValue)
		createOperationProvidedRoleForLuaComponent(newValue)
	}
}

reaction RemovedLuaComponent {
	after element lua::Component removed from lua::ComponentSet[components]
	call {
		removeOperationProvidedRoleForLuaComponent(oldValue)
		removeOperationInterfaceForLuaComponent(oldValue)
		removeBasicComponentForLuaComponent(oldValue)
	}
}

reaction AddedParameter {
	after element lua::Referenceable inserted in lua::Function[arguments]
	call {
		if (affectedEObject.eContainer instanceof Statement_Function_Declaration) {
			createParameter(newValue, affectedEObject.eContainer as Statement_Function_Declaration)
		}
	}
}

reaction RemovedParameter {
	after element lua::Referenceable removed from lua::Function[arguments]
	call {
		deleteParameter(oldValue)
	}
}

reaction AddedDeclaration {
	after element lua::Statement_Function_Declaration inserted in lua::Block[statements]
	call {
		if (SeffHelper.needsSeffReconstruction(newValue)) {
			createOperationSignatureForStatementFunctionDeclaration(newValue)
		}
	}
}

reaction RemovedDeclaration {
	after element lua::Statement_Function_Declaration removed from lua::Block[statements]
	call {
		logger.debug(oldValue.name + ": Function with SEFF removed")
		removeOperationSignatureForStatementFunctionDeclaration(oldValue)
	}
}

reaction AddedStatement {
	after element lua::Statement inserted in lua::Block[statements]
	call {
		createActionsForStatement(newValue, affectedEObject)
	}
}

reaction RemovedStatement {
	after element lua::Statement removed from lua::Block[statements]
	call {
		removeActionsForStatement(oldValue, affectedEObject)
	}
}

reaction ChangedStatement {
	after anychange 
	call {
		if (change instanceof FeatureEChange) {
			val affected = change.affectedEObject
			val parentStatement = EcoreUtil2.getContainerOfType(affected, Statement)
			if (parentStatement === null) {
				return
			}

			val parentBlock = EcoreUtil2.getContainerOfType(parentStatement, Block)
			if (parentBlock === null) {
				return
			}
			
			// track which statements we have refreshed this propagation so we don't do it a hundred times
			val info = ComponentSetInfoRegistry.getInfosForComponentSet(parentStatement)
			if (info !== null) {
				if (info.refreshedStatements.contains(parentStatement)) {
					return
				}
				info.refreshedStatements.add(parentStatement)
			}
			replaceActionsForStatement(parentStatement, parentBlock, change)
		}
		
	}
}

reaction AddedServeCall {
	after element lua::Expression_Functioncall_Direct created
	call {
		if (AppSpaceSemantics.isServingFunctionCall(affectedEObject)) {
			var decl = AppSpaceSemantics.getFunctionDeclarationFromServingFunctionCall(affectedEObject)
			if (decl !== null) {
				logger.info("ServeCall for declaration was added: " + decl.name)
				createSeffForDeclaration(decl)
			} else {
				logger.info("Cannot locate declaration for new serve call")
			}
		}
	}
}

reaction RemovedServeCall {
	after element lua::Expression_Functioncall_Direct deleted
//	after element lua::Expression_Functioncall_Direct removed from lua::Block[statements]
	call {
		tryRemoveSeffForServeCall(affectedEObject)
	}
}

routine tryRemoveSeffForServeCall(lua::Expression_Functioncall_Direct potentialServeCall) {
	match {
		val servedDeclaration = retrieve optional lua::Statement_Function_Declaration corresponding to potentialServeCall
	}
	update {
		if (servedDeclaration.empty) {
			return
		}

		val decl = servedDeclaration.get
		var otherServeCall = ActionReconstruction.getServeCallForDeclaration(decl)
		if (otherServeCall !== null) {
			logger.info("Serve call moved / changed, not deleting SEFF for: " + decl.name)
			return
		}
		
		
		logger.info("ServeCall for declaration was removed: " + decl.name)
		removeSeffForDeclaration(decl)
	}
}

routine createRDBehaviourForBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
		val basicComponent = retrieve optional pcm::BasicComponent corresponding to LuaUtil.getComponent(block)
		val operationSignature = retrieve optional pcm::OperationSignature corresponding to LuaUtil.
			getDeclaration(block)
		val parentAction = retrieve optional pcm::AbstractAction corresponding to EcoreUtil2.
			getContainerOfType(block, Statement)
	}
	update {
		if (!ActionReconstruction.needsActionReconstruction(block)) {
			// no seff reconstruction needed
			return
		}

		if (rdBehaviour.present) {
			logger.debug(ActionUtil.getBlockName(block) + ": RD behaviour already exists for block")
			return
		}

		val parentStatement = EcoreUtil2.getContainerOfType(block, Statement)
		logger.debug(String.format("%s (%s): Needs SEFF reconstruction", block, parentStatement.class.name))

		if (parentStatement instanceof Statement_Function_Declaration) {
			if (!basicComponent.present) {
				logger.warn("Component of Block has no corresponding basic component")
				return
			}
			if (!operationSignature.present) {
				logger.warn("Declaration of Block has no corresponding operation signature")
				return
			}

			// add correspondence to the serve call
			var serveCall = ActionReconstruction.getServeCallForDeclaration(parentStatement)
			parentStatement.addCorrespondenceBetween(serveCall)

			// create the RDSEFF for the block
			createRDSeff(block, parentStatement, basicComponent.get, operationSignature.get)

		} else {
			if (!parentAction.present) {
				logger.warn("Inner block has no parent action")
				return
			}

			// create the RDBehaviour for the block
			createRDBehaviour(block, parentAction.get)
		}
	}
}

routine removeRDBehaviourForBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.info("Block deleted: Removing RD Behaviour " + rdBehaviour.id)
		removeCorrespondenceBetween(rdBehaviour, block)
		for (action : rdBehaviour.steps_Behaviour) {
			EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(action.id)
		}
		rdBehaviour.removeObject
	}
}

routine createRDSeff(lua::Block block, lua::Statement_Function_Declaration declaration, pcm::BasicComponent basicComponent, pcm::OperationSignature operationSignature) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
	}
	create {
		val rdSeff = new pcm::ResourceDemandingSEFF
	}
	update {
		logger.debug("Creating RDSeff " + rdSeff.id)
		rdSeff.basicComponent_ServiceEffectSpecification = basicComponent
		rdSeff.describedService__SEFF = operationSignature

		initializeRDBehaviour(rdSeff, ActionUtil.getBlockName(block))
		addCorrespondenceBetween(rdSeff, block)
		addCorrespondenceBetween(rdSeff, declaration)
		basicComponent.serviceEffectSpecifications__BasicComponent += rdSeff
	}
}

routine createRDBehaviour(lua::Block block, pcm::AbstractAction parentAction) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
	}
	create {
		val rdBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		logger.debug(block.toString + ": Creating RDBehaviour")
		initializeRDBehaviour(rdBehaviour, ActionUtil.getBlockName(block))
		addCorrespondenceBetween(rdBehaviour, block)
		addRDBehaviourToParentAction(parentAction, rdBehaviour, block)
	}
}

routine addRDBehaviourToParentAction(pcm::AbstractAction parentAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	update {
		if (parentAction instanceof LoopAction) {
			logger.debug("Adding RD Behaviour to parent loop action")
			val loopAction = parentAction
			loopAction.bodyBehaviour_Loop = rdBehaviour
		} else if (parentAction instanceof BranchAction) {
			if (!createBranchTransitionForBranchAction(parentAction, rdBehaviour, block)) {
				logger.error("Unable to create branch transitions for branch action")
			}
		}
	}
}

routine createBranchTransitionForBranchAction(pcm::BranchAction branchAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	create {
		val branchTransition = new pcm::ProbabilisticBranchTransition
	}
	update {
		logger.debug("Adding Branch to parent branch action")
		branchTransition.setBranchBehaviour_BranchTransition(rdBehaviour)

		// the conditional branches are all block wrappers, so we can use this to determine
		// if the added block is an else block
		val isElseBranch = !block.eContainmentFeature.equals(LuaPackage.Literals.BLOCK_WRAPPER__BLOCK)
		if (Config.descriptiveNames) {
			if (isElseBranch) {
				branchTransition.entityName = "ELSE_BRANCH"
			} else {
				branchTransition.entityName = "CONDITIONAL_BRANCH"
			}
		}

		// has this action a synthentic else branch
		val syntheticElseBranch = BranchActionUtil.getSyntheticBranchTransition(branchAction)

		// make sure there is always an else branch (synthetic or not)
		if (syntheticElseBranch.empty && !isElseBranch) {
			createSyntheticElseBranch(branchAction)
		} else if (syntheticElseBranch.present && isElseBranch) {
			removeSyntheticElseBranch(branchAction)
		}

		// add the actual branch transition
		branchAction.branches_Branch.add(branchTransition);

		// make all branches equally probable
		val branchCount = branchAction.branches_Branch.size
		for (branch : branchAction.branches_Branch) {
			(branch as ProbabilisticBranchTransition).setBranchProbability(1.0 / (branchCount as double))
		}
	}
}

routine createSyntheticElseBranch(pcm::BranchAction branchAction) {
	create {
		val syntheticNotTakenBranch = new pcm::ProbabilisticBranchTransition
		val emptyBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		syntheticNotTakenBranch.setBranchBehaviour_BranchTransition(emptyBehaviour)
		syntheticNotTakenBranch.entityName = BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH;
		initializeRDBehaviour(emptyBehaviour, "SYNTHETIC_ELSE_BEHAVIOUR")
		branchAction.branches_Branch.add(syntheticNotTakenBranch);
		addCorrespondenceBetween(branchAction, syntheticNotTakenBranch)
	}
}

routine removeSyntheticElseBranch(pcm::BranchAction branchAction) {
	update {
		for (branch : branchAction.branches_Branch) {
			if (branch.entityName == BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH) {
				// empty the branches behaviour
				var branchBehaviour = branch.branchBehaviour_BranchTransition
				// these deletions don't propagate into the IM sadly
				branchBehaviour.steps_Behaviour.retainAll(#[])

				logger.debug("Done deleting else branch")

				branch.branchBehaviour_BranchTransition.removeObject
				branchAction.branches_Branch -= branch
				removeCorrespondenceBetween(branchAction, branch)
				branch.removeObject
			}
		}
	}
}

routine initializeRDBehaviour(pcm::ResourceDemandingBehaviour rdBehaviour, String name) {
	create {
		val startAction = new pcm::StartAction
		val stopAction = new pcm::StopAction
	}
	update {
		if (Config.descriptiveNames) {
			startAction.entityName = name + "_START"
			stopAction.entityName = name + "_STOP"
		}

		ActionUtil.chainActions(startAction, stopAction)

		rdBehaviour.steps_Behaviour += startAction
		rdBehaviour.steps_Behaviour += stopAction
	}
}

routine createBasicComponentForLuaComponent(lua::Component luaComponent) {
	match {
		require absence of pcm::BasicComponent corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	create {
		val pcmBasicComponent = new pcm::BasicComponent
	}
	update {
		pcmBasicComponent.entityName = luaComponent.name
		pcmRepository.components__Repository += pcmBasicComponent
		addCorrespondenceBetween(pcmBasicComponent, luaComponent)
	}
}

routine removeBasicComponentForLuaComponent(lua::Component luaComponent) {
	match {
		val pcmBasicComponent = retrieve pcm::BasicComponent corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	update {
		removeCorrespondenceBetween(pcmBasicComponent, luaComponent)
		pcmRepository.components__Repository -= pcmBasicComponent
		pcmBasicComponent.removeObject
	}
}

routine createOperationInterfaceForLuaComponent(lua::Component luaComponent) {
	match {
		require absence of pcm::OperationInterface corresponding to luaComponent
		val pcmComponent = retrieve pcm::BasicComponent corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	create {
		val operationInterface = new pcm::OperationInterface
	}
	update {
		if (Config.descriptiveNames) {
			operationInterface.entityName = luaComponent.name + "_interface"
		} else {
			operationInterface.entityName = luaComponent.name
		}
		pcmRepository.interfaces__Repository += operationInterface
		addCorrespondenceBetween(luaComponent, operationInterface)
		addCorrespondenceBetween(pcmComponent, operationInterface)
	}
}

routine removeOperationInterfaceForLuaComponent(lua::Component luaComponent) {
	match {
		val operationInterface = retrieve pcm::OperationInterface corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	update {
		pcmRepository.interfaces__Repository -= operationInterface
		removeCorrespondenceBetween(luaComponent, operationInterface)
		operationInterface.removeObject
	}
}

routine createOperationProvidedRoleForLuaComponent(lua::Component luaComponent) {
	match {
		require absence of pcm::OperationProvidedRole corresponding to luaComponent
		val basicComponent = retrieve pcm::BasicComponent corresponding to luaComponent
		val operationInterface = retrieve pcm::OperationInterface corresponding to luaComponent
	}
	create {
		val operationProvidedRole = new pcm::OperationProvidedRole
	}
	update {
		operationProvidedRole.providedInterface__OperationProvidedRole = operationInterface
		operationProvidedRole.providingEntity_ProvidedRole = basicComponent
		if (Config.descriptiveNames) {
			operationProvidedRole.entityName = luaComponent.name + "_providing_role"
		} else {
			operationProvidedRole.entityName = luaComponent.name
		}
		basicComponent.providedRoles_InterfaceProvidingEntity += operationProvidedRole

		addCorrespondenceBetween(operationProvidedRole, luaComponent)
	}
}

routine removeOperationProvidedRoleForLuaComponent(lua::Component luaComponent) {
	match {
		val operationProvidedRole = retrieve pcm::OperationProvidedRole corresponding to luaComponent
		val basicComponent = retrieve pcm::BasicComponent corresponding to luaComponent
	}
	update {
		removeCorrespondenceBetween(luaComponent, operationProvidedRole)
		basicComponent.providedRoles_InterfaceProvidingEntity -= operationProvidedRole
		operationProvidedRole.removeObject
	}
}

routine createParameter(lua::Referenceable functionParameter, lua::Statement_Function_Declaration functionDeclaration) {
	match {
		require absence of pcm::Parameter corresponding to functionParameter
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	create {
		val pcmParameter = new pcm::Parameter
	}
	update {
		pcmParameter.parameterName = functionParameter.name
		pcmParameter.dataType__Parameter = luaAnyType

		addCorrespondenceBetween(functionParameter, pcmParameter)
		
		var argIndex = functionDeclaration.function.arguments.indexOf(functionParameter)
		if (argIndex < operationSignature.parameters__OperationSignature.size) {
			operationSignature.parameters__OperationSignature.add(argIndex, pcmParameter)
		} else {
			operationSignature.parameters__OperationSignature.add(pcmParameter)
		}
		
		// this has no be after the parameter is inserted into the signature
		pcmParameter.operationSignature__Parameter = operationSignature
	}
}

routine deleteParameter(lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		pcmParameter.removeObject
	}
}

routine createActionsForStatement(EObject statement, lua::Block block) {
	match {
		val existingActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (!ActionReconstruction.needsActionReconstruction(statement)) {
			return
		}

		if (!rdBehaviour.present) {
			logger.warn("Unable to create actions for statements: no RD Behaviour")
			return
		}

		if (existingActions.size > 0) {
			logger.debug("Action(s) already present for statement " + statement + ": " + existingActions)
			return
		}

		val statementActions = ActionReconstruction.getActionsForStatement(statement, correspondenceModel)
		if (statementActions.size < 1) {
			return
		}

		// does this statement only contain internal calls?
		var internalStatement = true
		for (action : statementActions) {
			if (!(action instanceof InternalAction)) {
				internalStatement = false
			}
		}

		logger.debug(String.format("%s: %d action(s) reconstructed", statement, statementActions.size()))

		var previousAction = ActionUtil.getPreviousActionOfStatement(statement, block, rdBehaviour.get,
			correspondenceModel);
		var subsequentAction = ActionUtil.getSubsequentActionOfStatement(statement, block, rdBehaviour.get,
			correspondenceModel);
			
		// are we surrounded by a fused action?
		if (previousAction.equals(subsequentAction)) {
			if (internalStatement) {
				logger.debug("Fusing internal statement into surrounding fused action")
				addCorrespondenceBetween(previousAction, statement)
				actionStatementRelationChanged(previousAction)
				
				for (action : statementActions) {
					EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(action.id)
					action.removeObject
				}
				return
			} else {
				splitFusedActionAtStatement(previousAction, statement, block)		
				
				// recalculate previous and subsequent because the changed because of the split
				previousAction = ActionUtil.getPreviousActionOfStatement(statement, block, rdBehaviour.get,
					correspondenceModel);
				subsequentAction = ActionUtil.getSubsequentActionOfStatement(statement, block, rdBehaviour.get,
					correspondenceModel);
			}
		}

		// every new action is possibly fused with this action
		var actionToCheckForFusing = previousAction;

		// insert the actions of the statement into the step behaviour
		var insertionIndex = rdBehaviour.get.steps_Behaviour.indexOf(previousAction) + 1

		for (action : statementActions) {
			addCorrespondenceBetween(action, statement)
			if (actionToCheckForFusing instanceof InternalAction && action instanceof InternalAction) {
				// we fuse with the previous internal action and don't need a separate internal action here
				fuseTwoInternalActions(actionToCheckForFusing as InternalAction, action as InternalAction)
			} else {
				if (action instanceof ExternalCallAction) {
					logger.debug("External call was found")
					val componentOfStatement = LuaUtil.getComponent(statement)
					createRequiredRoleForExternalCallAction(action, rdBehaviour.get, componentOfStatement)
				}

				logger.debug("Action is added to step behaviour")
				// insert the action into the step behaviour
				ActionUtil.chainActions(previousAction, action)
				rdBehaviour.get.steps_Behaviour.add(insertionIndex, action)
				insertionIndex += 1
				actionToCheckForFusing = action

				EvaluationDataContainer.get.imUpdateEvalData.createdActions.add(action.id);
			}
		}

		// possibly fuse the last action with the subsequent action
		// we don't fuse the previousAction and the subsequentAction
		// (because that would imply the are both InternalActions which should not happen)
		if (actionToCheckForFusing !== previousAction && actionToCheckForFusing instanceof InternalAction &&
			subsequentAction instanceof InternalAction) {
			logger.debug("Fusing last statement action with subsequent action")
			fuseTwoInternalActions(actionToCheckForFusing as InternalAction, subsequentAction as InternalAction)
		} else {
			ActionUtil.chainActions(actionToCheckForFusing, subsequentAction)
		}
	}
}

routine splitFusedActionAtStatement(pcm::AbstractAction actionToSplit, EObject statement, lua::Block block) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
		val actionStatements = retrieve many lua::Statement corresponding to actionToSplit
		val lastStatements = retrieve many lua::LastStatement corresponding to actionToSplit
	}
	update {
		logger.info("Splitting a fused action")
		
		// split the action using the index of the given statement
		var splitIndex = block.statements.indexOf(statement)
		
		var secondAction = SeffFactory.eINSTANCE.createInternalAction()

		// transfer correspondences to the second action where needed
		for (actionStatement  : actionStatements) {
			var statementIndex = block.statements.indexOf(actionStatement)
			if (statementIndex > splitIndex) {
				logger.debug("Moving statement to second action of split")
				removeCorrespondenceBetween(actionToSplit, actionStatement)
				addCorrespondenceBetween(secondAction, actionStatement)
			}
		}
		actionStatementRelationChanged(actionToSplit)

		val newSuccessor = actionToSplit.successor_AbstractAction
		secondAction.predecessor_AbstractAction = actionToSplit
		secondAction.successor_AbstractAction = newSuccessor
		
		val actionInsertIndex = rdBehaviour.steps_Behaviour.indexOf(actionToSplit)
		rdBehaviour.steps_Behaviour.add(actionInsertIndex+1, secondAction)

		
		// TODO this does not handle last statements at all
	}
}

routine fuseTwoInternalActions(pcm::InternalAction a, pcm::InternalAction b) {
	match {
		val statementsCorrespondingToB = retrieve many lua::Statement corresponding to b
	}
	update {
		logger.debug("Fusing two internal actions")
		// transfer the correspondences from b to a and delete b
		statementsCorrespondingToB.forEach [
			addCorrespondenceBetween(a, it)
			b.removeCorrespondenceBetween(it)
		]


		// if we added this action this propagation we also need to remove it from the eval data
		EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(b.id)
		b.removeObject
		

		actionStatementRelationChanged(a)

		if (Config.descriptiveNames) {
			var newStatementCount = CorrespondenceUtil.getCorrespondingEObjectsByType(correspondenceModel, a,
				Statement).size()
			a.entityName = String.format("Internal: %d statements", newStatementCount)
		}
	}
}

routine actionStatementRelationChanged(pcm::AbstractAction action) {
	match {
		val aip = retrieve optional im::ActionInstrumentationPoint corresponding to action
	}
	update {
		// we changed an action by fusing more statements into it
		// -> These statements must be instrumented, so we enable the AIP
		if (aip.present && !aip.get.active) {
			logger.info("Action was changed. Activating its Instrumentation Point")
			aip.get.active = true
		}
		
		// track the changed action for the evaluation
		EvaluationDataContainer.get.imUpdateEvalData.getFusedActions.add(action.id);
	}
}

routine removeActionsForStatement(EObject statement, lua::Block block) {
	match {
		val statementActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.debug("Statement with actions removed: " + statement)
		for (action : statementActions) {
			action.removeCorrespondenceBetween(statement)
			// delete if the action has no other corresponding statements
			tryDeleteAction(action, rdBehaviour)
		}
	}
}

routine replaceActionsForStatement(lua::Statement statement, lua::Block block, EObject change) {
	match {
		val statementActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (!ActionReconstruction.needsActionReconstruction(statement)) {
			return
		}

		if (!rdBehaviour.present) {
			logger.warn("Unable to replace actions for statements: no RD Behaviour")
			return
		}
		
		logger.info("Recreating actions of a changed statement")
		for (action : statementActions) {
			recreateActionsForCorrespondingStatements(action)
		}
	}
}

routine recreateActionsForCorrespondingStatements(pcm::AbstractAction action) {
	match {
		val statements = retrieve many lua::Statement corresponding to action
	}
	update {
		for (statement : statements) {
			val block = EcoreUtil2.getContainerOfType(statement, Block)
			removeActionsForStatement(statement, block)
		}
		for (statement : statements) {
			val block = EcoreUtil2.getContainerOfType(statement, Block)
			createActionsForStatement(statement, block)
		}
	}
}

routine tryDeleteAction(pcm::AbstractAction action, pcm::ResourceDemandingBehaviour rdBehaviour) {
	match {
		val statementsOfAction = retrieve many lua::Statement corresponding to action
		val requiredRolesOfAction = retrieve many pcm::OperationRequiredRole corresponding to action
	}
	update {
		// if the action has not corresponding to any statements anymore we delete it
		if (statementsOfAction.size == 0) {
			logger.debug("Action has no corresponding statements left. Deleting")
			removeAction(action, rdBehaviour)
		} else {
			logger.debug("Action has no corresponding statements left. Not deleting")
		}
	}
}

routine removeAction(pcm::AbstractAction action, pcm::ResourceDemandingBehaviour rdBehaviour) {
	match {
		val requiredRolesOfAction = retrieve many pcm::OperationRequiredRole corresponding to action
	}
	update {
		if (action instanceof ExternalCallAction) {
			removeRequiredRoleForExternalCallAction(action)
		}

		logger.debug(action.toString + ": Removing action from RD behaviour" + rdBehaviour.toString)

		// fixing the chaining of the remaining actions or fuse them
		val pred = action.predecessor_AbstractAction
		val succ = action.successor_AbstractAction

		if (pred instanceof InternalAction && succ instanceof InternalAction) {
			logger.info("Fusing two now adjacent internal actions")
			var newSuccessor = succ.successor_AbstractAction
			fuseTwoInternalActions(pred as InternalAction, succ as InternalAction)
			pred.successor_AbstractAction = newSuccessor

		} else {
			if (pred !== null) {
				pred.successor_AbstractAction = succ
			}
			if (succ !== null) {
				succ.predecessor_AbstractAction = pred
			}
		}

		rdBehaviour.steps_Behaviour -= action

		EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(action.id)
		action.removeObject
	}
}

routine createRequiredRoleForExternalCallAction(pcm::ExternalCallAction action, pcm::ResourceDemandingBehaviour rdseff, lua::Component callingComponent) {
	match {
		val calledComponent = retrieve optional lua::Component corresponding to action
	}
	update {
		if (calledComponent.empty) {
			logger.warn("ExternalCall action is missing component correspondences: " + action.toString)
			return
		}

		findOrCreateOperationRequiredRole(action, callingComponent, calledComponent.get)
	}
}

routine findOrCreateOperationRequiredRole(pcm::ExternalCallAction action, lua::Component callingComponent, lua::Component calledComponent) {
	match {
		val existingRole = retrieve optional pcm::OperationRequiredRole corresponding to action
		val requiredInterface = retrieve optional pcm::OperationInterface corresponding to calledComponent
		val pcmCallingComponent = retrieve optional pcm::BasicComponent corresponding to callingComponent
	}
	update {
		if (existingRole.present) {
			logger.warn("External action is already associated with a required role")
			return
		}
		if (requiredInterface.empty) {
			logger.warn("Unable to find required interface for creation of a required role")
			return
		}
		if (pcmCallingComponent.empty) {
			logger.warn("Unable to find calling pcm component for creation of a required role")
			return
		}

		// is there already a role for calls from this component to the called component?
		// -> then use it
		val existingRequiredRoleForInterface = pcmCallingComponent.get.requiredRoles_InterfaceRequiringEntity.stream().
			filter [
				requiredInterface.get.equals((it as OperationRequiredRole).requiredInterface__OperationRequiredRole)
			].map [
				it as OperationRequiredRole
			].findAny

		if (existingRequiredRoleForInterface.present) {
			logger.debug("Found role for requiring interface")
			bindExternalCallAndRequiredRole(action, existingRequiredRoleForInterface.get)

		} else {
			logger.debug("Required role needs to be created")
			createOperationRequiredRole(action, pcmCallingComponent.get, requiredInterface.get)
		}
	}
}

routine createOperationRequiredRole(pcm::ExternalCallAction action, pcm::BasicComponent pcmCallingComponent, pcm::OperationInterface requiredInterface) {
	match {
		val calledComponent = retrieve pcm::BasicComponent corresponding to requiredInterface
	}
	create {
		val operationRequiredRole = new pcm::OperationRequiredRole
	}
	update {
		logger.debug("Creating OperationRequiredRole")
		operationRequiredRole.requiringEntity_RequiredRole = pcmCallingComponent
		operationRequiredRole.requiredInterface__OperationRequiredRole = requiredInterface
		operationRequiredRole.entityName = calledComponent.entityName // + "_requiring_role"
		// add the role to the calling component
		pcmCallingComponent.requiredRoles_InterfaceRequiringEntity += operationRequiredRole

		// make sure the action uses the role
		bindExternalCallAndRequiredRole(action, operationRequiredRole)
	}
}

routine bindExternalCallAndRequiredRole(pcm::ExternalCallAction action, pcm::OperationRequiredRole requiredRole) {
	update {
		action.role_ExternalService = requiredRole
		addCorrespondenceBetween(action, requiredRole)
	}
}

routine removeRequiredRoleForExternalCallAction(pcm::ExternalCallAction action) {
	match {
		val operationRequiredRole = retrieve pcm::OperationRequiredRole corresponding to action
		val allActionsOfRequiredRole = retrieve many pcm::ExternalCallAction corresponding to operationRequiredRole
	}
	update {
		action.removeCorrespondenceBetween(operationRequiredRole)

		// if there were no other corresponding actions, we delete the role	
		if (allActionsOfRequiredRole.size == 1) {
			logger.debug("Removing OperationRequiredRole")
			operationRequiredRole.removeObject
		} else {
			logger.debug("Not removing required role as it is still needed")
		}
	}
}


routine createOperationSignatureForStatementFunctionDeclaration(lua::Statement_Function_Declaration functionDeclaration) {
	match {
		val operationInterface = retrieve pcm::OperationInterface corresponding to LuaUtil.getComponent(
			functionDeclaration)
		require absence of pcm::OperationSignature corresponding to functionDeclaration
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	create {
		val operationSignature = new pcm::OperationSignature
	}
	update {
		logger.info(functionDeclaration.name + ": Creating signature")

		operationSignature.entityName = functionDeclaration.name
		operationSignature.interface__OperationSignature = operationInterface
		operationInterface.signatures__OperationInterface += operationSignature
		
		val rootBlock = functionDeclaration.function.block
		if (rootBlock !== null) {
			val returnValue = rootBlock.returnValue
			if (returnValue !== null) {
				operationSignature.returnType__OperationSignature = luaAnyType
			}

			makeSureRootBlockUsesSig(rootBlock, operationSignature)
		} else {
			logger.warn("no root block")
		}


		addCorrespondenceBetween(functionDeclaration, operationSignature)

		// some external call actions may be created before this signature is created, so we fix the ExternalCallAction
		// set signature in external call actions which are calling this declaration
		ComponentSetInfoRegistry.getInfosForComponentSet(functionDeclaration).declarationToCallingActions.get(
			functionDeclaration).forEach [
			if (it instanceof ExternalCallAction) {
				logger.warn(functionDeclaration.name + ": ExternalCallAction for newly created signature exists")
				it.calledService_ExternalService = operationSignature
				addCorrespondenceBetween(it, operationSignature)
				
				val callingComponent = EcoreUtil2.getContainerOfType(it, BasicComponent)
				if (it.role_ExternalService === null) {
					// our parent interface did not exist when this external action was created
					// we need to create it now
					createOperationRequiredRole(it, callingComponent, operationInterface)
				}
			}
		]
	}
}

routine makeSureRootBlockUsesSig(lua::Block block, pcm::OperationSignature sig) {
	match {
		val rdSeff = retrieve pcm::ResourceDemandingSEFF corresponding to block
	}
	update {
		if (!rdSeff.describedService__SEFF.equals(sig)) {
			rdSeff.describedService__SEFF = sig
		}
	}
}

routine removeOperationSignatureForStatementFunctionDeclaration(lua::Statement_Function_Declaration functionDeclaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration
	}
	update {
		logger.info(functionDeclaration.name + ": Removing signature")
		if (functionDeclaration.function !== null) {
			for (param : functionDeclaration.function.arguments) {
				deleteParameter(param)
			}
		}
		
		fixExternalCallsOfSoonToBeDeletedSignature(operationSignature)								

		removeCorrespondenceBetween(operationSignature, functionDeclaration)
		removeObject(operationSignature)
	}
}

routine fixExternalCallsOfSoonToBeDeletedSignature(pcm::OperationSignature sig) {
	match {
		val extCalls = retrieve many pcm::ExternalCallAction corresponding to sig
	}
	update {
		for (extCall : extCalls) {
			logger.debug("Recreating actions for statement corresponding to external call: " + extCall.id)
			recreateActionsForCorrespondingStatements(extCall)
		}
	}
}

routine createSeffForDeclaration(lua::Statement_Function_Declaration declaration) {
	match {
		val rdSeff = retrieve optional pcm::ResourceDemandingSEFF corresponding to declaration
		val operationSignature = retrieve optional pcm::OperationSignature corresponding to declaration
	}
	update {
		if (rdSeff.present) {
			logger.debug("SEFF for new serve call was already present for: " + declaration.name)
			return
		}
		logger.info("Catching up on SEFF creation for " + declaration.name)

		// this is needed because the declaration and the seff were added in separate commits
		if (!operationSignature.present) {
			createOperationSignatureForStatementFunctionDeclaration(declaration)
		}

		// create RD behaviours for all blocks
		for (block : EcoreUtil2.getAllContentsOfType(declaration, Block)) {
			createRDBehaviourForBlock(block)

			for (statement : block.statements) {
				createActionsForStatement(statement, block)
			}
		}
	}
}

routine removeSeffForDeclaration(LuaFunctionDeclaration declaration) {
	match {
		val rdSeff = retrieve optional pcm::ResourceDemandingSEFF corresponding to declaration
	}
	update {
		if (!rdSeff.present) {
			logger.warn("Unable to remove non-existent RDSEFF")
			return
		}
		logger.info("Removing SEFF of function because its serve call was deleted: " + declaration.name)

		removeOperationSignatureForStatementFunctionDeclaration(declaration)

		// remove all the RD behaviours and actions
		for (block : EcoreUtil2.getAllContentsOfType(declaration, Block)) {
			removeRDBehaviourForBlock(block)

			for (statement : block.statements) {
				removeActionsForStatement(statement, block)
			}
		}
	}
}

