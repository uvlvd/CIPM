import cipm.consistency.base.models.instrumentation.InstrumentationModel.InstrumentationModelPackage
import cipm.consistency.commitintegration.lang.lua.appspace.AppSpaceSemantics
import cipm.consistency.cpr.luapcm.Config
import cipm.consistency.cpr.luapcm.seffreconstruction.ActionReconstruction
import cipm.consistency.cpr.luapcm.seffreconstruction.ActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.BranchActionUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.ComponentSetInfoRegistry
import cipm.consistency.cpr.luapcm.seffreconstruction.CorrespondenceUtil
import cipm.consistency.cpr.luapcm.seffreconstruction.SeffHelper
import cipm.consistency.cpr.luapcm.seffreconstruction.LuaFunctionDeclaration
import cipm.consistency.tools.evaluation.data.EvaluationDataContainer
import org.eclipse.xtext.EcoreUtil2
import org.palladiosimulator.pcm.repository.BasicComponent
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.seff.BranchAction
import org.palladiosimulator.pcm.seff.ExternalCallAction
import org.palladiosimulator.pcm.seff.InternalAction
import org.palladiosimulator.pcm.seff.LoopAction
import org.palladiosimulator.pcm.seff.ProbabilisticBranchTransition
import org.palladiosimulator.pcm.seff.SeffFactory
//import org.xtext.lua.lua.LuaUtil
import org.xtext.lua.lua.Block
//import org.xtext.lua.lua.LastStatement_Return_WithValue
import org.xtext.lua.lua.LuaPackage
import org.xtext.lua.lua.Stat
import org.xtext.lua.component_extension.Component
import org.xtext.lua.component_extension.Application
import org.xtext.lua.component_extension.NamedChunk
//import org.xtext.lua.lua.Statement_Function_Declaration
import tools.vitruv.change.atomic.feature.FeatureEChange
import cipm.consistency.cpr.luapcm.LuaPcmUpdateUtil
import org.xtext.lua.lua.Return
import cipm.consistency.cpr.luapcm.seffreconstruction.LuaUtil
import org.xtext.lua.utils.LinkingAndScopingUtils
import cipm.consistency.cpr.luapcm.seffreconstruction.LuaFunctionCall

import "http://www.example.org/component_extension" as ce
import "http://www.xtext.org/lua/Lua" as lua
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm
import "http://www.dmodel.com/InstrumentationMetamodel" as im

reactions: luaPcmUpdate
in reaction to changes in lua and ce
execute actions in pcm and im

/** 
 * 
 * TODO TODO TODO
 * 
 * This is a nasty hack!
 * 
 * I'm having issues deactivating the action instrumentation points of the IM from outside the VSUM,
 * as the view that has the IM only returns an invalid IM without any point, which makes modifying them 
 * impossible.
 * 
 * So as a hack im doing it here
 */
reaction DeactivateAllIPs {
	after anychange
	call {
		if (change instanceof FeatureEChange) {
			var info = ComponentSetInfoRegistry.getInfosForComponentSet(change.affectedEObject)
			if (info !== null && !info.emulatedInstrumentationRan) {
				logger.warn("Deactivating all AIPs to emulate a complete instrumentation")
				deactiveAllAIPs()
				info.emulatedInstrumentationRan = true
			}
		}
	}
}

routine deactiveAllAIPs() {
	match {
		val im = retrieve im::InstrumentationModel corresponding to InstrumentationModelPackage.Literals.
			INSTRUMENTATION_MODEL
	}
	update {
		for (sip : im.points) {
			for (aip : sip.actionInstrumentationPoints) {
				aip.active = false
			}
		}
	}
}

reaction AddedBlock {
	after element lua::Block created
	call {
		createRDBehaviourForBlock(affectedEObject)
		//updateStepsBehaviour(affectedEObject, affectedEObject.returnValue, null)
		updateStepsBehaviour(affectedEObject, affectedEObject.lastStat, null)
	}
}

reaction RemovedBlock {
	after element lua::Block deleted
	call {
		removeRDBehaviourForBlock(affectedEObject)
	}
}


// TODO this was added last minute and could probably use a look over
reaction ChangedBlockReturn {
	//after element replaced at lua::Block[returnValue]
	after element replaced at lua::Block[lastStat]
	call {
		//val parentDeclaration = EcoreUtil2.getContainerOfType(affectedEObject, Statement_Function_Declaration)
		val parentDeclaration = LuaPcmUpdateUtil.getParentFunctionDeclarationEObject(affectedEObject)
		if (parentDeclaration !== null) {
			updateOperationSignature(parentDeclaration, newValue)
			updateStepsBehaviour(affectedEObject, newValue, oldValue)
		}
	}
}

reaction RemovedBlockReturn {
	//after element removed from lua::Block[returnValue]
	after element removed from lua::Block[lastStat]
	call {
		removeActionsForStatement(oldValue, affectedEObject)
	}
}

//routine updateStepsBehaviour(lua::Block block, lua::LastStatement lastStatement, lua::LastStatement prev) {
routine updateStepsBehaviour(lua::Block block, lua::LastStat lastStatement, lua::LastStat prev) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (prev === null && lastStatement !== null) {
			createActionsForStatement(lastStatement, block)
		} else if (prev !== null && lastStatement === null) {
			removeActionsForStatement(prev, block)
		}
	}
}

/**
 * The passed EObject should be a lua function declaration, not any kind of EObject.
 */
// TODO move this to the other routines
//routine updateOperationSignature(lua::Statement_Function_Declaration declaration, lua::LastStatement returnValue) {
routine updateOperationSignature(EObject declaration, lua::LastStat returnValue) {
	match {
		val signature = retrieve optional pcm::OperationSignature corresponding to declaration
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	update {
		if (signature.empty) {
			return
		}
		//if (returnValue instanceof LastStatement_Return_WithValue) {
		if (returnValue instanceof Return) {
			//if (returnValue.returnValues.size > 0) {
			if (returnValue.expList !== null && returnValue.expList.exps.size > 0) {
				signature.get.returnType__OperationSignature = luaAnyType
				return
			}
		}
		signature.get.returnType__OperationSignature = null
	}
}

reaction AddedLuaComponent {
	after element ce::Component inserted in ce::Application[components]
	call {
		//if (newValue.name == "/stdlibAndCrowns.lua") {
		//	return
		//}
		createBasicComponentForLuaComponent(newValue)
		createOperationInterfaceForLuaComponent(newValue)
		createOperationProvidedRoleForLuaComponent(newValue)
	}
}

reaction RemovedLuaComponent {
	after element ce::Component removed from ce::Application[components]
	call {
		removeOperationProvidedRoleForLuaComponent(oldValue)
		removeOperationInterfaceForLuaComponent(oldValue)
		removeBasicComponentForLuaComponent(oldValue)
	}
}

reaction AddedParameter {
	//after element lua::Referenceable inserted in lua::Function[arguments]
	after element lua::Referenceable inserted in lua::ArgList[args]
	call {
		//if (affectedEObject.eContainer instanceof Statement_Function_Declaration) {
		val declaration = LuaPcmUpdateUtil.buildParentFunctionDeclarationOf(affectedEObject)
		if (declaration != null) {
			createParameter(newValue, declaration)
		}
	}
}

reaction RemovedParameter {
	//after element lua::Referenceable removed from lua::Function[arguments]
	after element lua::Referenceable removed from lua::ArgList[args]
	call {
		deleteParameter(oldValue)
	}
}




//***********************************************
//** Reactions for added function declarations **
//***********************************************

// TODO: we have three types of declarations, thus we need to define this reaction three times. There might be a better way to 
// do this with the reactions language, that I don't know about
reaction AddedDeclaration {
	//after element lua::Statement_Function_Declaration inserted in lua::Block[statements]
	after element lua::FunctionDeclaration inserted in lua::Block[stats]
	call {
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(newValue)
		//if (SeffHelper.needsSeffReconstruction(newValue)) {
		if (SeffHelper.needsSeffReconstruction(declaration)) {
			//createOperationSignatureForStatementFunctionDeclaration(newValue)
			createOperationSignatureForStatementFunctionDeclaration(declaration)
		}
	}
}
reaction AddedLocalDeclaration {
	//after element lua::Statement_Function_Declaration inserted in lua::Block[statements]
	after element lua::LocalFunctionDeclaration inserted in lua::Block[stats]
	call {
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(newValue)
		//if (SeffHelper.needsSeffReconstruction(newValue)) {
		if (SeffHelper.needsSeffReconstruction(declaration)) {
			//createOperationSignatureForStatementFunctionDeclaration(newValue)
			createOperationSignatureForStatementFunctionDeclaration(declaration)
		}
	}
}
//TODO: these assumes that we only need to react to ExpFunctionDeclarations inserted into ExpLists and Fields, not e.g. into ParamArgs.
//	this should be extended at some point if necessary
reaction AddedExpDeclarationIntoExpList {
	//after element lua::Statement_Function_Declaration inserted in lua::Block[statements]
	after element lua::ExpFunctionDeclaration inserted in lua::ExpList[exps]
	call {
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(newValue)
		//if (SeffHelper.needsSeffReconstruction(newValue)) {
		if (SeffHelper.needsSeffReconstruction(declaration)) {
			//createOperationSignatureForStatementFunctionDeclaration(newValue)
			createOperationSignatureForStatementFunctionDeclaration(declaration)
		}
	}
}
reaction AddedExpDeclarationIntoFieldList {
	//after element lua::Statement_Function_Declaration inserted in lua::Block[statements]
	after element lua::Field inserted in lua::FieldList[fields]
	call {
		val expFunctionDeclaration = LuaPcmUpdateUtil.getExpFunctionDeclarationFromField(newValue)
		if (expFunctionDeclaration !== null) {
			val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(expFunctionDeclaration)
			//if (SeffHelper.needsSeffReconstruction(newValue)) {
			if (SeffHelper.needsSeffReconstruction(declaration)) {
				//createOperationSignatureForStatementFunctionDeclaration(newValue)
				createOperationSignatureForStatementFunctionDeclaration(declaration)
			}
		}
		
	}
}




//*************************************************
//** Reactions for removed function declarations **
//*************************************************

// TODO: same as with adding function declarations, we need to define multiple reactions for the different
// function-declaration types. There should be a better way to do this..

reaction RemovedDeclaration {
	after element lua::FunctionDeclaration removed from lua::Block[stats]
	call {
		logger.debug(oldValue.name + ": Function with SEFF removed")
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(oldValue)
		if (declaration !== null) {
			removeOperationSignatureForStatementFunctionDeclaration(declaration)
		} else {
			logger.error("Could not remove function " + oldValue.name)
		}
	}
}
reaction RemovedLocalDeclaration {
	after element lua::LocalFunctionDeclaration removed from lua::Block[stats]
	call {
		logger.debug(oldValue.name + ": Function with SEFF removed")
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(oldValue)
		if (declaration !== null) {
			removeOperationSignatureForStatementFunctionDeclaration(declaration)
		} else {
			logger.error("Could not remove function " + oldValue.name)
		}
	}
}
//TODO: these assume that we only need to react to ExpFunctionDeclarations inserted into ExpLists and Fields, not e.g. into ParamArgs.
//	this should be extended at some point if necessary
reaction RemovedExpDeclarationIntoExpList {
	after element lua::ExpFunctionDeclaration removed from lua::ExpList[exps]
	call {	
		logger.debug(oldValue.name + ": Function with SEFF removed")
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(oldValue)
		if (declaration !== null) {
			removeOperationSignatureForStatementFunctionDeclaration(declaration)
		} else {
			logger.error("Could not remove function " + oldValue.name)
		}
	}
}
reaction RemovedExpDeclarationIntoFieldList {
	//after element lua::Statement_Function_Declaration inserted in lua::Block[statements]
	after element lua::Field removed from lua::FieldList[fields]
	call {
		val expFunctionDeclaration = LuaPcmUpdateUtil.getExpFunctionDeclarationFromField(oldValue)
		if (expFunctionDeclaration !== null) {
			logger.debug(oldValue.name + ": Function with SEFF removed")
			val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(oldValue)
			if (declaration !== null) {
				removeOperationSignatureForStatementFunctionDeclaration(declaration)
			} else {
				logger.error("Could not remove function " + oldValue.name)
			}
		}
	}
}


//**************************************
//** Reactions for changed Statements **
//**************************************

reaction AddedStatement {
	after element lua::Stat inserted in lua::Block[stats]
	call {
		createActionsForStatement(newValue, affectedEObject)
	}
}

reaction RemovedStatement {
	after element lua::Stat removed from lua::Block[stats]
	call {
		removeActionsForStatement(oldValue, affectedEObject)
	}
}

reaction ChangedStatement {
	after anychange 
	call {
		if (change instanceof FeatureEChange) {
			val affected = change.affectedEObject
			//val parentStatement = EcoreUtil2.getContainerOfType(affected, Statement)
			val parentStatementOpt = LinkingAndScopingUtils.getParentStatement(affected);
			if (parentStatementOpt.isEmpty) {
				return
			}
			
			val parentStatement = parentStatementOpt.get
			val parentBlock = EcoreUtil2.getContainerOfType(parentStatement, Block)
			if (parentBlock === null) {
				return
			}
			
			// track which statements we have refreshed this propagation so we don't do it a hundred times
			val info = ComponentSetInfoRegistry.getInfosForComponentSet(parentStatement)
			if (info !== null) {
				if (info.refreshedStatements.contains(parentStatement)) {
					return
				}
				info.refreshedStatements.add(parentStatement)
			}
			replaceActionsForStatement(parentStatement, parentBlock, change)
		}
		
	}
}





//****************************************
//** Reactions for added function calls **
//****************************************

// TODO: here we have the same problems as for FunctionDeclarations, i.e. multiple types of calls are present in the Lua CM:
//   FunctionCall, MethodCall and FunctionCallStat

//reaction AddedServeCall {
reaction AddedFunctionCallStat {
	after element lua::FunctionCallStat created
	call {
		val functionCall = LuaPcmUpdateUtil.buildFunctionCall(affectedEObject)
		//if (AppSpaceSemantics.isServingFunctionCall(affectedEObject)) {
		if (functionCall !== null && functionCall.isExternal() && !functionCall.isMocked()) {
			//var decl = AppSpaceSemantics.getFunctionDeclarationFromServingFunctionCall(affectedEObject)
			var declaration = functionCall.getCalledFunction // null-check already performed by calling isMocked()
			//if (decl !== null) {
			logger.info("ServeCall for declaration was added: " + declaration.name)
			createSeffForDeclaration(declaration)
			//} else {
			//	logger.info("Cannot locate declaration for new serve call")
			//}
		}
	}
}
reaction AddedFunctionCall {
	after element lua::FunctionCall created
	call {
		val functionCall = LuaPcmUpdateUtil.buildFunctionCall(affectedEObject)
		if (functionCall !== null && functionCall.isExternal() && !functionCall.isMocked()) {
			var declaration = functionCall.getCalledFunction // null-check already performed by calling isMocked()
			logger.info("ServeCall for declaration was added: " + declaration.name)
			createSeffForDeclaration(declaration)
		}
	}
}
reaction AddedMethodCall {
	after element lua::MethodCall created
	call {
		val functionCall = LuaPcmUpdateUtil.buildFunctionCall(affectedEObject)
		if (functionCall !== null && functionCall.isExternal() && !functionCall.isMocked()) {
			var declaration = functionCall.getCalledFunction // null-check already performed by calling isMocked()
			logger.info("ServeCall for declaration was added: " + declaration.name)
			createSeffForDeclaration(declaration)
		}
	}
}

//******************************************
//** Reactions for removed function calls **
//******************************************
// TODO: same redundancies as for adding function calls, adding/removing function declarations..

reaction RemovedFunctionCallStat {
	after element lua::FunctionCallStat deleted
	call {
		var functionCall = LuaPcmUpdateUtil.buildFunctionCall(affectedEObject)
		tryRemoveSeffForServeCall(functionCall)
	}
}
reaction RemovedFunctionCal {
	after element lua::FunctionCall deleted
	call {
		var functionCall = LuaPcmUpdateUtil.buildFunctionCall(affectedEObject)
		tryRemoveSeffForServeCall(functionCall)
	}
}
reaction RemovedMethodCall {
	after element lua::MethodCall deleted
	call {
		var functionCall = LuaPcmUpdateUtil.buildFunctionCall(affectedEObject)
		tryRemoveSeffForServeCall(functionCall)
	}
}

// comment jsaenz: I am not sure what this logic is intended to do, so I'm just adapting it to the new CM
//  but cannot be sure if it is needed or correctly implemented. Summary of what I understand:
//           - this calls ActionReconstruction.getServeCallForDeclaration
//           - which calls ComponentSetInfoRegistry to get the ComponentSetInfos
//           - in the componentsetInfo there is a map apparently containing the last "served" function call returned by 
// 			   EcoreUtil2.getAllContentsOfType(application, Expression_Functioncall_Direct.class)
//					-> this might have been changed by my adaptation, since FunctionCallStat, FunctionCall, and MethodCall EObjects are now
//			           added in sequence, i.e. the last "served" function call is the last MethodCall if one is present, else a FunctionCall, etc.	
//routine tryRemoveSeffForServeCall(lua::Expression_Functioncall_Direct potentialServeCall) {
routine tryRemoveSeffForServeCall(plain LuaFunctionCall as potentialServeCall) {	
	match {
		// comment jsaenz: not sure what this does, but the old servedDeclaration should now be LuaFunctionCall.getFunctionCall().getRoot()
		//val servedDeclaration = retrieve optional lua::Statement_Function_Declaration corresponding to potentialServeCall
		val servedDeclaration = retrieve optional EObject corresponding to potentialServeCall.getCallingFeature()
	}
	update {
		
		// TODO: not sure if this does the same as the previous impementation, see comments above this function 
		// and commented code of previous implementation and above and below
		
		// first attempt at adaptation:
		//if (potentialServeCall.isMocked()) {
		//	return
		//}
		//val declaration = potentialServeCall.getCalledFunction()
		//var otherServeCall = ActionReconstruction.getServeCallForDeclaration(declaration)
		//if (otherServeCall !== null) {
	//		logger.info("Serve call moved / changed, not deleting SEFF for: " + declaration.name)
//			return
		//}
		
		if (servedDeclaration.isEmpty()) {
			return
		}
		val declaration = LuaPcmUpdateUtil.buildFunctionDeclaration(servedDeclaration.get());
		if (declaration === null) return
		// TODO: this will probably not work, since the declaration here and the one returned by getServeCallForDeclaration
		//       are not the same Java Objects! -> should implement the Map in ComponentSetInfo in such a way that it contains the Lua
		//       object, not the LuaFunctionDeclaration as key, or some other identifier as key 
		var otherServeCall = ActionReconstruction.getServeCallForDeclaration(declaration)
		if (otherServeCall !== null) {
			logger.info("Serve call moved / changed, not deleting SEFF for: " + declaration.name)
			return
		}
		
		
		
		
		logger.info("ServeCall for declaration was removed: " + declaration.name)
		removeSeffForDeclaration(declaration)

		//if (servedDeclaration.empty) {
		//	return
		//}
		//val decl = servedDeclaration.get
		//var otherServeCall = ActionReconstruction.getServeCallForDeclaration(decl)
		//if (otherServeCall !== null) {
		//	logger.info("Serve call moved / changed, not deleting SEFF for: " + decl.name)
		//	return
		//}
		
		
		//logger.info("ServeCall for declaration was removed: " + decl.name)
		//removeSeffForDeclaration(decl)

		
	}
}







routine createRDBehaviourForBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
		val basicComponent = retrieve optional pcm::BasicComponent corresponding to LuaUtil.getComponent(block)
		//val operationSignature = retrieve optional pcm::OperationSignature corresponding to LuaUtil.getDeclaration(block)
		val operationSignature = retrieve optional pcm::OperationSignature corresponding to LuaPcmUpdateUtil.getParentFunctiondeclarationAsEObject(block)	
		// TODO: jsaenz: not sure if this works as intended with the new Lua CM
		val parentAction = retrieve optional pcm::AbstractAction corresponding to EcoreUtil2.getContainerOfType(block, Stat)
	}
	update {
		if (!ActionReconstruction.needsActionReconstruction(block)) {
			// no seff reconstruction needed
			return
		}

		if (rdBehaviour.present) {
			logger.debug(ActionUtil.getBlockName(block) + ": RD behaviour already exists for block")
			return
		}

		val parentStatement = EcoreUtil2.getContainerOfType(block, Stat)
		logger.debug(String.format("%s (%s): Needs SEFF reconstruction", block, parentStatement.class.name))

		val functionDeclaration = LuaPcmUpdateUtil.buildFunctionDeclaration(parentStatement);
		if (functionDeclaration !== null) {
			if (!basicComponent.present) {
				logger.warn("Component of Block has no corresponding basic component")
				return
			}
			if (!operationSignature.present) {
				logger.warn("Declaration of Block has no corresponding operation signature")
				return
			}

			// add correspondence to the serve call
			//var serveCall = ActionReconstruction.getServeCallForDeclaration(parentStatement)
			//parentStatement.addCorrespondenceBetween(serveCall)
			var functionCall = ActionReconstruction.getServeCallForDeclaration(functionDeclaration)
			parentStatement.addCorrespondenceBetween(functionCall.getCallingFeature())

			// create the RDSEFF for the block
			createRDSeff(block, basicComponent.get, operationSignature.get, functionDeclaration)

		} else {
			if (!parentAction.present) {
				logger.warn("Inner block has no parent action")
				return
			}

			// create the RDBehaviour for the block
			createRDBehaviour(block, parentAction.get)
		}
	}
}

routine removeRDBehaviourForBlock(lua::Block block) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.info("Block deleted: Removing RD Behaviour " + rdBehaviour.id)
		removeCorrespondenceBetween(rdBehaviour, block)
		for (action : rdBehaviour.steps_Behaviour) {
			EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(action.id)
		}
		rdBehaviour.removeObject
	}
}

/**
 * Assumes that the given declaration is not null.
 */
//routine createRDSeff(lua::Block block, lua::Statement_Function_Declaration declaration, pcm::BasicComponent basicComponent, pcm::OperationSignature operationSignature) {
routine createRDSeff(lua::Block block, 
					 pcm::BasicComponent basicComponent, 
					 pcm::OperationSignature operationSignature,
					 plain LuaFunctionDeclaration as declaration
	) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
	}
	create {
		val rdSeff = new pcm::ResourceDemandingSEFF
	}
	update {
		logger.debug("Creating RDSeff " + rdSeff.id)
		rdSeff.basicComponent_ServiceEffectSpecification = basicComponent
		rdSeff.describedService__SEFF = operationSignature

		initializeRDBehaviour(rdSeff, ActionUtil.getBlockName(block))
		addCorrespondenceBetween(rdSeff, block)
		addCorrespondenceBetween(rdSeff, declaration.getRoot())
		basicComponent.serviceEffectSpecifications__BasicComponent += rdSeff
	}
}

routine createRDBehaviour(lua::Block block, pcm::AbstractAction parentAction) {
	match {
		require absence of pcm::ResourceDemandingBehaviour corresponding to block
	}
	create {
		val rdBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		logger.debug(block.toString + ": Creating RDBehaviour")
		initializeRDBehaviour(rdBehaviour, ActionUtil.getBlockName(block))
		addCorrespondenceBetween(rdBehaviour, block)
		addRDBehaviourToParentAction(parentAction, rdBehaviour, block)
	}
}

routine addRDBehaviourToParentAction(pcm::AbstractAction parentAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	update {
		if (parentAction instanceof LoopAction) {
			logger.debug("Adding RD Behaviour to parent loop action")
			val loopAction = parentAction
			loopAction.bodyBehaviour_Loop = rdBehaviour
		} else if (parentAction instanceof BranchAction) {
			if (!createBranchTransitionForBranchAction(parentAction, rdBehaviour, block)) {
				logger.error("Unable to create branch transitions for branch action")
			}
		}
	}
}

routine createBranchTransitionForBranchAction(pcm::BranchAction branchAction, pcm::ResourceDemandingBehaviour rdBehaviour, lua::Block block) {
	create {
		val branchTransition = new pcm::ProbabilisticBranchTransition
	}
	update {
		logger.debug("Adding Branch to parent branch action")
		branchTransition.setBranchBehaviour_BranchTransition(rdBehaviour)

		// comment jsaenz: I'm no sure what the following comment means, but it seems that this determines if the block is the block following the "then" of a IfThenElse or ElseIf
		// the conditional branches are all block wrappers, so we can use this to determine
		// if the added block is an else block
		//val isElseBranch = !block.eContainmentFeature.equals(LuaPackage.Literals.BLOCK_WRAPPER__BLOCK)
		//if (Config.descriptiveNames) {
	//		if (isElseBranch) {
//				branchTransition.entityName = "ELSE_BRANCH"
//			} else {
//				branchTransition.entityName = "CONDITIONAL_BRANCH"
//			}
//		}

		// comment jsaenz: this should do the same as the above
		//val isElseBranch = !(block.eContainmentFeature.equals(LuaPackage.Literals.IF_THEN_ELSE__THEN_BLOCK)
		//					|| block.eContainer instanceof ElseIf)
		val isElseBranch = block.eContainmentFeature.equals(LuaPackage.Literals.IF_THEN_ELSE__ELSE_BLOCK)
		if (Config.descriptiveNames) {
			if (isElseBranch) {
				branchTransition.entityName = "ELSE_BRANCH"
			} else {
				branchTransition.entityName = "CONDITIONAL_BRANCH"
			}
		}

		// has this action a synthentic else branch
		val syntheticElseBranch = BranchActionUtil.getSyntheticBranchTransition(branchAction)

		// make sure there is always an else branch (synthetic or not)
		if (syntheticElseBranch.empty && !isElseBranch) {
			createSyntheticElseBranch(branchAction)
		} else if (syntheticElseBranch.present && isElseBranch) {
			removeSyntheticElseBranch(branchAction)
		}

		// add the actual branch transition
		branchAction.branches_Branch.add(branchTransition);

		// make all branches equally probable
		val branchCount = branchAction.branches_Branch.size
		for (branch : branchAction.branches_Branch) {
			(branch as ProbabilisticBranchTransition).setBranchProbability(1.0 / (branchCount as double))
		}
	}
}

routine createSyntheticElseBranch(pcm::BranchAction branchAction) {
	create {
		val syntheticNotTakenBranch = new pcm::ProbabilisticBranchTransition
		val emptyBehaviour = new pcm::ResourceDemandingBehaviour
	}
	update {
		syntheticNotTakenBranch.setBranchBehaviour_BranchTransition(emptyBehaviour)
		syntheticNotTakenBranch.entityName = BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH;
		initializeRDBehaviour(emptyBehaviour, "SYNTHETIC_ELSE_BEHAVIOUR")
		branchAction.branches_Branch.add(syntheticNotTakenBranch);
		addCorrespondenceBetween(branchAction, syntheticNotTakenBranch)
	}
}

routine removeSyntheticElseBranch(pcm::BranchAction branchAction) {
	update {
		for (branch : branchAction.branches_Branch) {
			if (branch.entityName == BranchActionUtil.NAME_SYNTHETIC_ELSE_BRANCH) {
				// empty the branches behaviour
				var branchBehaviour = branch.branchBehaviour_BranchTransition
				// these deletions don't propagate into the IM sadly
				branchBehaviour.steps_Behaviour.retainAll(#[])

				logger.debug("Done deleting else branch")

				branch.branchBehaviour_BranchTransition.removeObject
				branchAction.branches_Branch -= branch
				removeCorrespondenceBetween(branchAction, branch)
				branch.removeObject
			}
		}
	}
}

routine initializeRDBehaviour(pcm::ResourceDemandingBehaviour rdBehaviour, String name) {
	create {
		val startAction = new pcm::StartAction
		val stopAction = new pcm::StopAction
	}
	update {
		if (Config.descriptiveNames) {
			startAction.entityName = name + "_START"
			stopAction.entityName = name + "_STOP"
		}

		ActionUtil.chainActions(startAction, stopAction)

		rdBehaviour.steps_Behaviour += startAction
		rdBehaviour.steps_Behaviour += stopAction
	}
}

routine createBasicComponentForLuaComponent(ce::Component luaComponent) {
	match {
		require absence of pcm::BasicComponent corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	create {
		val pcmBasicComponent = new pcm::BasicComponent
	}
	update {
		pcmBasicComponent.entityName = luaComponent.name
		pcmRepository.components__Repository += pcmBasicComponent
		addCorrespondenceBetween(pcmBasicComponent, luaComponent)
	}
}

routine removeBasicComponentForLuaComponent(ce::Component luaComponent) {
	match {
		val pcmBasicComponent = retrieve pcm::BasicComponent corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	update {
		removeCorrespondenceBetween(pcmBasicComponent, luaComponent)
		pcmRepository.components__Repository -= pcmBasicComponent
		pcmBasicComponent.removeObject
	}
}

routine createOperationInterfaceForLuaComponent(ce::Component luaComponent) {
	match {
		require absence of pcm::OperationInterface corresponding to luaComponent
		val pcmComponent = retrieve pcm::BasicComponent corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	create {
		val operationInterface = new pcm::OperationInterface
	}
	update {
		if (Config.descriptiveNames) {
			operationInterface.entityName = luaComponent.name + "_interface"
		} else {
			operationInterface.entityName = luaComponent.name
		}
		pcmRepository.interfaces__Repository += operationInterface
		addCorrespondenceBetween(luaComponent, operationInterface)
		addCorrespondenceBetween(pcmComponent, operationInterface)
	}
}

routine removeOperationInterfaceForLuaComponent(ce::Component luaComponent) {
	match {
		val operationInterface = retrieve pcm::OperationInterface corresponding to luaComponent
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	update {
		pcmRepository.interfaces__Repository -= operationInterface
		removeCorrespondenceBetween(luaComponent, operationInterface)
		operationInterface.removeObject
	}
}

routine createOperationProvidedRoleForLuaComponent(ce::Component luaComponent) {
	match {
		require absence of pcm::OperationProvidedRole corresponding to luaComponent
		val basicComponent = retrieve pcm::BasicComponent corresponding to luaComponent
		val operationInterface = retrieve pcm::OperationInterface corresponding to luaComponent
	}
	create {
		val operationProvidedRole = new pcm::OperationProvidedRole
	}
	update {
		operationProvidedRole.providedInterface__OperationProvidedRole = operationInterface
		operationProvidedRole.providingEntity_ProvidedRole = basicComponent
		if (Config.descriptiveNames) {
			operationProvidedRole.entityName = luaComponent.name + "_providing_role"
		} else {
			operationProvidedRole.entityName = luaComponent.name
		}
		basicComponent.providedRoles_InterfaceProvidingEntity += operationProvidedRole

		addCorrespondenceBetween(operationProvidedRole, luaComponent)
	}
}

routine removeOperationProvidedRoleForLuaComponent(ce::Component luaComponent) {
	match {
		val operationProvidedRole = retrieve pcm::OperationProvidedRole corresponding to luaComponent
		val basicComponent = retrieve pcm::BasicComponent corresponding to luaComponent
	}
	update {
		removeCorrespondenceBetween(luaComponent, operationProvidedRole)
		basicComponent.providedRoles_InterfaceProvidingEntity -= operationProvidedRole
		operationProvidedRole.removeObject
	}
}

routine createParameter(lua::Referenceable functionParameter, plain LuaFunctionDeclaration as functionDeclaration) {
//routine createParameter(lua::Referenceable functionParameter, lua::Statement_Function_Declaration functionDeclaration) {
	match {
		require absence of pcm::Parameter corresponding to functionParameter
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
		val operationSignature = retrieve pcm::OperationSignature corresponding to functionDeclaration.getRoot
	}
	create {
		val pcmParameter = new pcm::Parameter
	}
	update {
		pcmParameter.parameterName = functionParameter.name
		pcmParameter.dataType__Parameter = luaAnyType

		addCorrespondenceBetween(functionParameter, pcmParameter)
		
		// we assume that the functionDeclaration has args if this createParameter function was called
		var argIndex = functionDeclaration.getArgs.indexOf(functionParameter)
		if (argIndex < operationSignature.parameters__OperationSignature.size) {
			operationSignature.parameters__OperationSignature.add(argIndex, pcmParameter)
		} else {
			operationSignature.parameters__OperationSignature.add(pcmParameter)
		}
		
		// this has no be after the parameter is inserted into the signature
		pcmParameter.operationSignature__Parameter = operationSignature
	}
}

routine deleteParameter(lua::Referenceable functionParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to functionParameter
	}
	update {
		pcmParameter.removeObject
	}
}

/**
 * We use EObject instead of Stat for the statement parameter, since it may be of type Stat or LastStat
 */
routine createActionsForStatement(EObject statement, lua::Block block) {
	match {
		val existingActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (!ActionReconstruction.needsActionReconstruction(statement)) {
			return
		}

		if (!rdBehaviour.present) {
			logger.warn("Unable to create actions for statements: no RD Behaviour")
			return
		}

		if (existingActions.size > 0) {
			logger.debug("Action(s) already present for statement " + statement + ": " + existingActions)
			return
		}

		val statementActions = ActionReconstruction.getActionsForStatement(statement, correspondenceModel)
		if (statementActions.size < 1) {
			return
		}

		// does this statement only contain internal calls?
		var internalStatement = true
		for (action : statementActions) {
			if (!(action instanceof InternalAction)) {
				internalStatement = false
			}
		}

		logger.debug(String.format("%s: %d action(s) reconstructed", statement, statementActions.size()))

		var previousAction = ActionUtil.getPreviousActionOfStatement(statement, block, rdBehaviour.get,
			correspondenceModel);
		var subsequentAction = ActionUtil.getSubsequentActionOfStatement(statement, block, rdBehaviour.get,
			correspondenceModel);
			
		// are we surrounded by a fused action?
		if (previousAction.equals(subsequentAction)) {
			if (internalStatement) {
				logger.debug("Fusing internal statement into surrounding fused action")
				addCorrespondenceBetween(previousAction, statement)
				actionStatementRelationChanged(previousAction)
				
				for (action : statementActions) {
					EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(action.id)
					action.removeObject
				}
				return
			} else {
				splitFusedActionAtStatement(previousAction, statement, block)		
				
				// recalculate previous and subsequent because the changed because of the split
				previousAction = ActionUtil.getPreviousActionOfStatement(statement, block, rdBehaviour.get,
					correspondenceModel);
				subsequentAction = ActionUtil.getSubsequentActionOfStatement(statement, block, rdBehaviour.get,
					correspondenceModel);
			}
		}

		// every new action is possibly fused with this action
		var actionToCheckForFusing = previousAction;

		// insert the actions of the statement into the step behaviour
		var insertionIndex = rdBehaviour.get.steps_Behaviour.indexOf(previousAction) + 1

		for (action : statementActions) {
			addCorrespondenceBetween(action, statement)
			if (actionToCheckForFusing instanceof InternalAction && action instanceof InternalAction) {
				// we fuse with the previous internal action and don't need a separate internal action here
				fuseTwoInternalActions(actionToCheckForFusing as InternalAction, action as InternalAction)
			} else {
				if (action instanceof ExternalCallAction) {
					logger.debug("External call was found")
					val componentOfStatement = LuaUtil.getComponent(statement)
					createRequiredRoleForExternalCallAction(action, rdBehaviour.get, componentOfStatement)
				}

				logger.debug("Action is added to step behaviour")
				// insert the action into the step behaviour
				ActionUtil.chainActions(previousAction, action)
				rdBehaviour.get.steps_Behaviour.add(insertionIndex, action)
				insertionIndex += 1
				actionToCheckForFusing = action

				EvaluationDataContainer.get.imUpdateEvalData.createdActions.add(action.id);
			}
		}

		// possibly fuse the last action with the subsequent action
		// we don't fuse the previousAction and the subsequentAction
		// (because that would imply the are both InternalActions which should not happen)
		if (actionToCheckForFusing !== previousAction && actionToCheckForFusing instanceof InternalAction &&
			subsequentAction instanceof InternalAction) {
			logger.debug("Fusing last statement action with subsequent action")
			fuseTwoInternalActions(actionToCheckForFusing as InternalAction, subsequentAction as InternalAction)
		} else {
			ActionUtil.chainActions(actionToCheckForFusing, subsequentAction)
		}
	}
}

routine splitFusedActionAtStatement(pcm::AbstractAction actionToSplit, EObject statement, lua::Block block) {
	match {
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
		val actionStatements = retrieve many lua::Stat corresponding to actionToSplit
		// comment jsaenz: lastStatments does not seem to be used
		val lastStatements = retrieve many lua::LastStat corresponding to actionToSplit
	}
	update {
		logger.info("Splitting a fused action")
		
		// split the action using the index of the given statement
		var splitIndex = block.stats.indexOf(statement)
		
		var secondAction = SeffFactory.eINSTANCE.createInternalAction()

		// transfer correspondences to the second action where needed
		for (actionStatement  : actionStatements) {
			var statementIndex = block.stats.indexOf(actionStatement)
			if (statementIndex > splitIndex) {
				logger.debug("Moving statement to second action of split")
				removeCorrespondenceBetween(actionToSplit, actionStatement)
				addCorrespondenceBetween(secondAction, actionStatement)
			}
		}
		actionStatementRelationChanged(actionToSplit)

		val newSuccessor = actionToSplit.successor_AbstractAction
		secondAction.predecessor_AbstractAction = actionToSplit
		secondAction.successor_AbstractAction = newSuccessor
		
		val actionInsertIndex = rdBehaviour.steps_Behaviour.indexOf(actionToSplit)
		rdBehaviour.steps_Behaviour.add(actionInsertIndex+1, secondAction)

		
		// TODO this does not handle last statements at all
	}
}

routine fuseTwoInternalActions(pcm::InternalAction a, pcm::InternalAction b) {
	match {
		val statementsCorrespondingToB = retrieve many lua::Stat corresponding to b
	}
	update {
		logger.debug("Fusing two internal actions")
		// transfer the correspondences from b to a and delete b
		statementsCorrespondingToB.forEach [
			addCorrespondenceBetween(a, it)
			b.removeCorrespondenceBetween(it)
		]


		// if we added this action this propagation we also need to remove it from the eval data
		EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(b.id)
		b.removeObject
		

		actionStatementRelationChanged(a)

		if (Config.descriptiveNames) {
			var newStatementCount = CorrespondenceUtil.getCorrespondingEObjectsByType(correspondenceModel, a,
				Stat).size()
			a.entityName = String.format("Internal: %d statements", newStatementCount)
		}
	}
}

routine actionStatementRelationChanged(pcm::AbstractAction action) {
	match {
		val aip = retrieve optional im::ActionInstrumentationPoint corresponding to action
	}
	update {
		// we changed an action by fusing more statements into it
		// -> These statements must be instrumented, so we enable the AIP
		if (aip.present && !aip.get.active) {
			logger.info("Action was changed. Activating its Instrumentation Point")
			aip.get.active = true
		}
		
		// track the changed action for the evaluation
		EvaluationDataContainer.get.imUpdateEvalData.getFusedActions.add(action.id);
	}
}

/**
 * We use EObject instead of Stat for the statement parameter, since it may be of type Stat or LastStat
 */
routine removeActionsForStatement(EObject statement, lua::Block block) {
	match {
		val statementActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		logger.debug("Statement with actions removed: " + statement)
		for (action : statementActions) {
			action.removeCorrespondenceBetween(statement)
			// delete if the action has no other corresponding statements
			tryDeleteAction(action, rdBehaviour)
		}
	}
}

routine replaceActionsForStatement(lua::Stat statement, lua::Block block, EObject change) {
	match {
		val statementActions = retrieve many pcm::AbstractAction corresponding to statement
		val rdBehaviour = retrieve optional pcm::ResourceDemandingBehaviour corresponding to block
	}
	update {
		if (!ActionReconstruction.needsActionReconstruction(statement)) {
			return
		}

		if (!rdBehaviour.present) {
			logger.warn("Unable to replace actions for statements: no RD Behaviour")
			return
		}
		
		logger.info("Recreating actions of a changed statement")
		for (action : statementActions) {
			recreateActionsForCorrespondingStatements(action)
		}
	}
}

routine recreateActionsForCorrespondingStatements(pcm::AbstractAction action) {
	match {
		val statements = retrieve many lua::Stat corresponding to action
	}
	update {
		for (statement : statements) {
			val block = EcoreUtil2.getContainerOfType(statement, Block)
			removeActionsForStatement(statement, block)
		}
		for (statement : statements) {
			val block = EcoreUtil2.getContainerOfType(statement, Block)
			createActionsForStatement(statement, block)
		}
	}
}

routine tryDeleteAction(pcm::AbstractAction action, pcm::ResourceDemandingBehaviour rdBehaviour) {
	match {
		val statementsOfAction = retrieve many lua::Stat corresponding to action
		val requiredRolesOfAction = retrieve many pcm::OperationRequiredRole corresponding to action
	}
	update {
		// if the action has not corresponding to any statements anymore we delete it
		if (statementsOfAction.size == 0) {
			logger.debug("Action has no corresponding statements left. Deleting")
			removeAction(action, rdBehaviour)
		} else {
			logger.debug("Action has no corresponding statements left. Not deleting")
		}
	}
}

routine removeAction(pcm::AbstractAction action, pcm::ResourceDemandingBehaviour rdBehaviour) {
	match {
		val requiredRolesOfAction = retrieve many pcm::OperationRequiredRole corresponding to action
	}
	update {
		if (action instanceof ExternalCallAction) {
			removeRequiredRoleForExternalCallAction(action)
		}

		logger.debug(action.toString + ": Removing action from RD behaviour" + rdBehaviour.toString)

		// fixing the chaining of the remaining actions or fuse them
		val pred = action.predecessor_AbstractAction
		val succ = action.successor_AbstractAction

		if (pred instanceof InternalAction && succ instanceof InternalAction) {
			logger.info("Fusing two now adjacent internal actions")
			var newSuccessor = succ.successor_AbstractAction
			fuseTwoInternalActions(pred as InternalAction, succ as InternalAction)
			pred.successor_AbstractAction = newSuccessor

		} else {
			if (pred !== null) {
				pred.successor_AbstractAction = succ
			}
			if (succ !== null) {
				succ.predecessor_AbstractAction = pred
			}
		}

		rdBehaviour.steps_Behaviour -= action

		EvaluationDataContainer.get.imUpdateEvalData.addActionRemoved(action.id)
		action.removeObject
	}
}

routine createRequiredRoleForExternalCallAction(pcm::ExternalCallAction action, pcm::ResourceDemandingBehaviour rdseff, ce::Component callingComponent) {
	match {
		val calledComponent = retrieve optional ce::Component corresponding to action
	}
	update {
		if (calledComponent.empty) {
			logger.warn("ExternalCall action is missing component correspondences: " + action.toString)
			return
		}

		findOrCreateOperationRequiredRole(action, callingComponent, calledComponent.get)
	}
}

routine findOrCreateOperationRequiredRole(pcm::ExternalCallAction action, ce::Component callingComponent, ce::Component calledComponent) {
	match {
		val existingRole = retrieve optional pcm::OperationRequiredRole corresponding to action
		val requiredInterface = retrieve optional pcm::OperationInterface corresponding to calledComponent
		val pcmCallingComponent = retrieve optional pcm::BasicComponent corresponding to callingComponent
	}
	update {
		if (existingRole.present) {
			logger.warn("External action is already associated with a required role")
			return
		}
		if (requiredInterface.empty) {
			logger.warn("Unable to find required interface for creation of a required role")
			return
		}
		if (pcmCallingComponent.empty) {
			logger.warn("Unable to find calling pcm component for creation of a required role")
			return
		}

		// is there already a role for calls from this component to the called component?
		// -> then use it
		val existingRequiredRoleForInterface = pcmCallingComponent.get.requiredRoles_InterfaceRequiringEntity.stream().
			filter [
				requiredInterface.get.equals((it as OperationRequiredRole).requiredInterface__OperationRequiredRole)
			].map [
				it as OperationRequiredRole
			].findAny

		if (existingRequiredRoleForInterface.present) {
			logger.debug("Found role for requiring interface")
			bindExternalCallAndRequiredRole(action, existingRequiredRoleForInterface.get)

		} else {
			logger.debug("Required role needs to be created")
			createOperationRequiredRole(action, pcmCallingComponent.get, requiredInterface.get)
		}
	}
}

routine createOperationRequiredRole(pcm::ExternalCallAction action, pcm::BasicComponent pcmCallingComponent, pcm::OperationInterface requiredInterface) {
	match {
		val calledComponent = retrieve pcm::BasicComponent corresponding to requiredInterface
	}
	create {
		val operationRequiredRole = new pcm::OperationRequiredRole
	}
	update {
		logger.debug("Creating OperationRequiredRole")
		operationRequiredRole.requiringEntity_RequiredRole = pcmCallingComponent
		operationRequiredRole.requiredInterface__OperationRequiredRole = requiredInterface
		operationRequiredRole.entityName = calledComponent.entityName // + "_requiring_role"
		// add the role to the calling component
		pcmCallingComponent.requiredRoles_InterfaceRequiringEntity += operationRequiredRole

		// make sure the action uses the role
		bindExternalCallAndRequiredRole(action, operationRequiredRole)
	}
}

routine bindExternalCallAndRequiredRole(pcm::ExternalCallAction action, pcm::OperationRequiredRole requiredRole) {
	update {
		action.role_ExternalService = requiredRole
		addCorrespondenceBetween(action, requiredRole)
	}
}

routine removeRequiredRoleForExternalCallAction(pcm::ExternalCallAction action) {
	match {
		val operationRequiredRole = retrieve pcm::OperationRequiredRole corresponding to action
		val allActionsOfRequiredRole = retrieve many pcm::ExternalCallAction corresponding to operationRequiredRole
	}
	update {
		action.removeCorrespondenceBetween(operationRequiredRole)

		// if there were no other corresponding actions, we delete the role	
		if (allActionsOfRequiredRole.size == 1) {
			logger.debug("Removing OperationRequiredRole")
			operationRequiredRole.removeObject
		} else {
			logger.debug("Not removing required role as it is still needed")
		}
	}
}


routine createOperationSignatureForStatementFunctionDeclaration(plain LuaFunctionDeclaration as functionDeclaration) {
	match {
		val operationInterface = retrieve pcm::OperationInterface corresponding to LuaUtil.getComponent(
			functionDeclaration)
		require absence of pcm::OperationSignature corresponding to functionDeclaration.getRoot
		val luaAnyType = retrieve pcm::DataType corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	create {
		val operationSignature = new pcm::OperationSignature
	}
	update {
		logger.info(functionDeclaration.name + ": Creating signature")

		operationSignature.entityName = functionDeclaration.name
		operationSignature.interface__OperationSignature = operationInterface
		operationInterface.signatures__OperationInterface += operationSignature
		
		val rootBlock = functionDeclaration.getBlock
		if (rootBlock !== null) {
			if (LuaPcmUpdateUtil.hasReturnValues(rootBlock)) {
				operationSignature.returnType__OperationSignature = luaAnyType
			}

			makeSureRootBlockUsesSig(rootBlock, operationSignature)
		} else {
			logger.warn("no root block")
		}


		addCorrespondenceBetween(functionDeclaration.getRoot, operationSignature)

		// some external call actions may be created before this signature is created, so we fix the ExternalCallAction
		// set signature in external call actions which are calling this declaration
		ComponentSetInfoRegistry.getInfosForComponentSet(functionDeclaration.getRoot).declarationToCallingActions.get(
			functionDeclaration).forEach [
			if (it instanceof ExternalCallAction) {
				logger.warn(functionDeclaration.name + ": ExternalCallAction for newly created signature exists")
				it.calledService_ExternalService = operationSignature
				addCorrespondenceBetween(it, operationSignature)
				
				val callingComponent = EcoreUtil2.getContainerOfType(it, BasicComponent)
				if (it.role_ExternalService === null) {
					// our parent interface did not exist when this external action was created
					// we need to create it now
					createOperationRequiredRole(it, callingComponent, operationInterface)
				}
			}
		]
	}
}

routine makeSureRootBlockUsesSig(lua::Block block, pcm::OperationSignature sig) {
	match {
		val rdSeff = retrieve pcm::ResourceDemandingSEFF corresponding to block
	}
	update {
		if (!rdSeff.describedService__SEFF.equals(sig)) {
			rdSeff.describedService__SEFF = sig
		}
	}
}

//routine removeOperationSignatureForStatementFunctionDeclaration(lua::Statement_Function_Declaration functionDeclaration) {
routine removeOperationSignatureForStatementFunctionDeclaration(plain LuaFunctionDeclaration as declaration) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to declaration.getRoot()
	}
	update {
		logger.info(declaration.name + ": Removing signature")
		//if (declaration.function !== null) {
		//	for (param : functionDeclaration.function.arguments) {
		//		deleteParameter(param)
		//	}
		//}
		
		val args = declaration.args
		if (args !== null) {
			for (arg : args) {
				deleteParameter(arg)
			}
		}
		
		fixExternalCallsOfSoonToBeDeletedSignature(operationSignature)								

		removeCorrespondenceBetween(operationSignature, declaration.getRoot())
		removeObject(operationSignature)
	}
}

routine fixExternalCallsOfSoonToBeDeletedSignature(pcm::OperationSignature sig) {
	match {
		val extCalls = retrieve many pcm::ExternalCallAction corresponding to sig
	}
	update {
		for (extCall : extCalls) {
			logger.debug("Recreating actions for statement corresponding to external call: " + extCall.id)
			recreateActionsForCorrespondingStatements(extCall)
		}
	}
}

//routine createSeffForDeclaration(lua::Statement_Function_Declaration declaration) {
routine createSeffForDeclaration(plain LuaFunctionDeclaration as declaration) {
	match {
		val rdSeff = retrieve optional pcm::ResourceDemandingSEFF corresponding to declaration.getRoot()
		val operationSignature = retrieve optional pcm::OperationSignature corresponding to declaration.getRoot()
	}
	update {
		if (rdSeff.present) {
			logger.debug("SEFF for new serve call was already present for: " + declaration.name)
			return
		}
		logger.info("Catching up on SEFF creation for " + declaration.name)

		// this is needed because the declaration and the seff were added in separate commits
		if (!operationSignature.present) {
			createOperationSignatureForStatementFunctionDeclaration(declaration)
		}

		// create RD behaviours for all blocks
		for (block : EcoreUtil2.getAllContentsOfType(declaration.getRoot(), Block)) {
			createRDBehaviourForBlock(block)

			for (statement : block.stats) {
				createActionsForStatement(statement, block)
			}
		}
	}
}

//routine removeSeffForDeclaration(lua::Statement_Function_Declaration declaration) {
routine removeSeffForDeclaration(plain LuaFunctionDeclaration as declaration) {
	match {
		val rdSeff = retrieve optional pcm::ResourceDemandingSEFF corresponding to declaration.getRoot()
	}
	update {
		if (!rdSeff.present) {
			logger.warn("Unable to remove non-existent RDSEFF")
			return
		}
		logger.info("Removing SEFF of function because its serve call was deleted: " + declaration.name)

		removeOperationSignatureForStatementFunctionDeclaration(declaration)

		// remove all the RD behaviours and actions
		for (block : EcoreUtil2.getAllContentsOfType(declaration.getRoot(), Block)) {
			removeRDBehaviourForBlock(block)

			for (statement : block.stats) {
				removeActionsForStatement(statement, block)
			}
		}
	}
}

